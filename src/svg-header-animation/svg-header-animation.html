<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="svg-header-animation">
	<template>
		<style>
			:host {
				display: block;
				pointer-events: none;
			}

			.wrapper {
				@apply --svg-wrapper-styles;
			}

			object {
				width: 100%;
				height: 100%;
			}

			/*
			 * This is to provide some translation interpolation for large mouse movements.
			 */
			* {
				transition: all 100ms;
			}
		</style>
		<div id="container">
		</div>
	</template>

	<script>
		Polymer({

			is: 'svg-header-animation',

			properties: {
				svgPath: {
					type: String,
				},
				numLayers: {
					type: Number,
					value: 5,
				},
				color: {
					type: String,
					value: "#FFF"
				},
				_center: {
					type: Object,
					value: {
						x: 0,
						y: 0,
					}
				},
				colorA: {
					type: String,
				},
				colorB: {
					type: String,
				},
				_colorAArr: {
					type: Array,
				},
				_colorBArr: {
					type: Array,
				},
			},
			behaviors: [
				Polymer.IronResizableBehavior,
			],
			listeners: {
				'iron-resize': '_computeCenter',
			},
			_computeCenter: function() {
				if(!this._layers) {
					return;
				}
				var center = {};
				var middleLayer = this._layers[Math.floor(this._layers.length / 2)];
				var bounds = middleLayer.element.getBoundingClientRect();
				center.x = bounds.x + bounds.width / 2;
				center.y = bounds.y + bounds.height / 2;
				this.set('_center', center);
			},
			ready: function () {
				var layers = this.generateLayers(this.svgPath, this.numLayers);
				layers = this.attachLayers(layers);
				this.set('_colorAArr', this._arrFromStr(this.colorA));
				this.set('_colorBArr', this._arrFromStr(this.colorB));
				layers = this.determineColors(layers, 'gradient');
				layers = this.applyColors(layers);
				layers = this.applyEffect(layers, '3d');
				setTimeout(this._computeCenter.bind(this), 0);
				this.set('_layers', layers);
			},
			/**
			 * @param {String} color The color hex string to convert.
			 */
			_arrFromStr: function(color) {
				if(!color) {
					return;
				}
				var arr = [0, 0, 0];
				arr[0] = parseInt(color.substr(0, 2), 16);
				arr[1] = parseInt(color.substr(2, 2), 16);
				arr[2] = parseInt(color.substr(4, 2), 16);
				return arr;
			},
			generateLayers: function(svgPath, numLayers) {
				var layers = [];
				for (var i = 0; i < numLayers; i++) {
					var obj = document.createElement('object');
					obj.type = 'image/svg+xml';
					obj.data = this.svgPath;
					obj.id = 'layer' + i;

					var layer = {};
					layer.id = 'layer' + i;
					layer.element = obj;
					layers.push(layer);
				}
				return layers;
			},
			attachLayers: function(layers) {
				for(var i = 0; i < layers.length; i++) {
					var wrapperDiv = document.createElement('div');
					wrapperDiv.classList += 'wrapper';
					wrapperDiv.appendChild(layers[i].element);
					layers[i].elementWrapper = wrapperDiv;
					Polymer.dom(this.$.container).appendChild(wrapperDiv);
				}
				return layers;
			},
			determineColors: function(layers, effect) {
				switch(effect) {
					default:
					case 'random':
						for(var i = 0; i < layers.length; i++) {
							layers[i].color = this.generateColorString(this.getRandomColor());
						}
						break;
					case 'gradient':
						var colorA = this._colorAArr || this.getRandomColor();
						var colorB = this._colorBArr || this.getRandomColor();
						// http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
						var rgbToHsv = function(rgb) {
							var rPrime = rgb[0]/255;
							var gPrime = rgb[1]/255;
							var bPrime = rgb[2]/255;
							var cMax = Math.max(rPrime, gPrime, bPrime);
							var cMin = Math.min(rPrime, gPrime, bPrime);
							var delta = cMax - cMin;
							var hue = (function(){
								if(delta === 0) {
									return 0;
								}
								else if(cMax === rPrime) {
									// modulus operator in javascript happily returns negative values
									// so we need to make sure it is positive
									var val = ((gPrime - bPrime)/delta) % 6;
									if(val < 0) { 
										val += 6;
									}
									return 60 * val;
								}
								else if(cMax === gPrime) {
									return 60 * (((bPrime - rPrime)/delta) + 2);
								}
								else if(cMax === bPrime) {
									return 60 * (((rPrime - gPrime)/delta) + 4);
								}
							}());
							var saturation = (function() {
								if(cMax === 0) {
									return 0;
								}
								else if (cMax !== 0) {
									return delta/cMax;
								}
							}());
							var value = cMax;
							return [hue, saturation, value];
						}
						// http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
						var hsvToRgb = function(hsv) {
							var h = hsv[0];
							var s = hsv[1];
							var v = hsv[2];
							var c = hsv[2] * hsv[1];
							var x = c * (1 - Math.abs(((hsv[0] / 60) % 2) - 1));
							var m = hsv[2] - c;
							var rPgPbP = (function() {
								if(0 <= h && h < 60) {
									return [c, x, 0];
								}
								else if(60 <= h && h < 120) {
									return [x, c, 0];
								}
								else if(120 <= h && h < 180) {
									return [0, c, x];
								}
								else if(180 <= h && h < 240) {
									return [0, x, c];
								}
								else if(240 <= h && h < 300) {
									return [x, 0, c];
								}
								else if(300 <= h && h < 360) {
									return [c, 0, x];
								}
							}());
							return [ (rPgPbP[0] + m) * 255, (rPgPbP[1] + m) * 255, (rPgPbP[2] + m) * 255];
						}
						var interpolateColor = function(hsvA, hsvB, percent) {
							var deltaH = hsvB[0] - hsvA[0];
							var deltaS = hsvB[1] - hsvA[1];
							var deltaV = hsvB[2] - hsvA[2];
							var temp = [hsvA[0] + (deltaH * percent), hsvA[1] + (deltaS * percent), hsvA[2] + (deltaV * percent)];
							return temp;
						}
						var hsvA = rgbToHsv(colorA);
						var hsvB = rgbToHsv(colorB);
						for(var i = 0; i < layers.length; i++) {
							layers[i].color = this.generateColorString(hsvToRgb(interpolateColor(hsvA, hsvB, i / layers.length)));
						}
				}
				return layers;
			},
			applyColors: function(layers) {
				for(var j = 0; j < layers.length; j++) {
					if(layers[j].element.contentDocument !== null) {
						var paths = layers[j].element.querySelectorAll('g');
						for(var i = 0; i < paths.length; i++) {
							paths[i].style.fill = layers[j].color;
						}
					}
					else {
						layers[j].element.onload = function(layer, event) {
							var paths = event.target.contentDocument.querySelectorAll('g');
							for(var i = 0; i < paths.length; i++) {
								paths[i].style.fill = layer.color;
							}
						}.bind(this, layers[j]);
					}
				}
				return layers;
			},
			applyEffect: function(layers, effect) {
				layers.effect && layers.effect();
				switch(effect) {
					default:
					case '3d':
						var apply = function(layers, normalX, normalY) {
							var middleIndex = Math.floor(layers.length / 2);
							for(var i = 0; i < layers.length; i++) {
								var layer = layers[i];
								layer.xTransform = normalX * (i - middleIndex);
								layer.yTransform = normalY * (i - middleIndex);
								layer.element.style.transform = 'translate(' + layer.xTransform + 'px,' + layer.yTransform + 'px)';
							}
						}
						var funcMouse = function(event) {
							var centerX = this._center.x;
							var centerY = this._center.y;
							var vecX = event.x - centerX;
							var vecY = event.y - centerY;
							var vecLen = Math.sqrt(vecX * vecX + vecY * vecY);
							var normalX = vecX / vecLen;
							var normalY = vecY / vecLen;
							var middleIndex = Math.floor(layers.length / 2);
							apply(layers, normalX * 5, normalY * 5);
						};
						var funcTouch = function(event) {
							event.preventDefault();
							var centerX = this._center.x;
							var centerY = this._center.y;
							var vecX = event.targetTouches[0].pageX - centerX;
							var vecY = event.targetTouches[0].pageY - centerY;
							var vecLen = Math.sqrt(vecX * vecX + vecY * vecY);
							var normalX = vecX / vecLen;
							var normalY = vecY / vecLen;
							var middleIndex = Math.floor(layers.length / 2);
							apply(layers, normalX * 5, normalY * 5);
						};
						layers.effect = function() {
							document.removeEventListener('mousemove', funcMouse.bind(this));
							document.removeEventListener('touchmove', funcTouch.bind(this));
						}.bind(this);
						document.addEventListener('mousemove', funcMouse.bind(this));
						document.addEventListener('touchmove', funcTouch.bind(this), { passive: false, });
						apply(layers, 5, 5);
						break;
				}
				return layers;
			},
			getRandomColor: function () {
				var color = [];
				for (var i = 0; i < 3; i++) {
					color[i] = Math.floor(Math.random() * 256);
				}
				return color;
			},
			generateColorString: function(rgb) {
				return rgb.map(function(val) {
					return Math.floor(val).toString(16);
				}).map(function(val) {
					return ('00' + val).substring(val.length);
				}).reduce(function(acc, val) {
					return acc + val;
				}, '#');
			}
		});
	</script>
</dom-module>